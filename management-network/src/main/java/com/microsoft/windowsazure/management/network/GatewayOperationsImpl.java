/**
 * 
 * Copyright (c) Microsoft and contributors.  All rights reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 */

// Warning: This code was generated by a tool.
// 
// Changes to this file may cause incorrect behavior and will be lost if the
// code is regenerated.

package com.microsoft.windowsazure.management.network;

import android.util.Xml;
import com.microsoft.windowsazure.AzureHttpStatus;
import com.microsoft.windowsazure.core.ServiceOperations;
import com.microsoft.windowsazure.core.utils.BOMInputStream;
import com.microsoft.windowsazure.core.utils.StreamUtils;
import com.microsoft.windowsazure.exception.ServiceException;
import com.microsoft.windowsazure.management.network.models.GatewayConnectDisconnectOrTestParameters;
import com.microsoft.windowsazure.management.network.models.GatewayConnectivityState;
import com.microsoft.windowsazure.management.network.models.GatewayCreateParameters;
import com.microsoft.windowsazure.management.network.models.GatewayEvent;
import com.microsoft.windowsazure.management.network.models.GatewayGenerateVpnClientPackageParameters;
import com.microsoft.windowsazure.management.network.models.GatewayGetDeviceConfigurationScriptParameters;
import com.microsoft.windowsazure.management.network.models.GatewayGetDeviceConfigurationScriptResponse;
import com.microsoft.windowsazure.management.network.models.GatewayGetOperationStatusResponse;
import com.microsoft.windowsazure.management.network.models.GatewayGetResponse;
import com.microsoft.windowsazure.management.network.models.GatewayGetSharedKeyResponse;
import com.microsoft.windowsazure.management.network.models.GatewayListConnectionsResponse;
import com.microsoft.windowsazure.management.network.models.GatewayListSupportedDevicesResponse;
import com.microsoft.windowsazure.management.network.models.GatewayOperationResponse;
import com.microsoft.windowsazure.management.network.models.GatewayOperationStatus;
import com.microsoft.windowsazure.management.network.models.GatewayResetSharedKeyParameters;
import com.microsoft.windowsazure.management.network.models.GatewaySetSharedKeyParameters;
import com.microsoft.windowsazure.management.network.models.GatewayType;
import com.microsoft.windowsazure.tracing.ClientRequestTrackingHandler;
import com.microsoft.windowsazure.tracing.CloudTracing;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.StringWriter;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.Calendar;
import java.util.HashMap;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import javax.xml.bind.DatatypeConverter;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlPullParserFactory;
import org.xmlpull.v1.XmlSerializer;

/**
* The Network Management API includes operations for managing the gateways for
* your subscription.  (see
* http://msdn.microsoft.com/en-us/library/windowsazure/jj154113.aspx for more
* information)
*/
public class GatewayOperationsImpl implements ServiceOperations<NetworkManagementClientImpl>, GatewayOperations {
    /**
    * Initializes a new instance of the GatewayOperationsImpl class.
    *
    * @param client Reference to the service client.
    */
    GatewayOperationsImpl(NetworkManagementClientImpl client) {
        this.client = client;
    }
    
    private NetworkManagementClientImpl client;
    
    /**
    * Gets a reference to the
    * microsoft.windowsazure.management.network.NetworkManagementClientImpl.
    * @return The Client value.
    */
    public NetworkManagementClientImpl getClient() {
        return this.client;
    }
    
    /**
    * To connect to, disconnect from, or test your connection to a local
    * network site, access the connection resource representing the local
    * network and specify Connect, Disconnect or Test to perform the desired
    * operation.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154107.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkSiteName Required. The name of the site to connect to.
    * @param parameters Required. Parameters supplied to the Begin Connect
    * Disconnect Or Testing Gateway operation.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public Future<GatewayOperationResponse> beginConnectDisconnectOrTestingAsync(final String networkName, final String localNetworkSiteName, final GatewayConnectDisconnectOrTestParameters parameters) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayOperationResponse>() { 
            @Override
            public GatewayOperationResponse call() throws Exception {
                return beginConnectDisconnectOrTesting(networkName, localNetworkSiteName, parameters);
            }
         });
    }
    
    /**
    * To connect to, disconnect from, or test your connection to a local
    * network site, access the connection resource representing the local
    * network and specify Connect, Disconnect or Test to perform the desired
    * operation.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154107.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkSiteName Required. The name of the site to connect to.
    * @param parameters Required. Parameters supplied to the Begin Connect
    * Disconnect Or Testing Gateway operation.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public GatewayOperationResponse beginConnectDisconnectOrTesting(String networkName, String localNetworkSiteName, GatewayConnectDisconnectOrTestParameters parameters) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        if (localNetworkSiteName == null) {
            throw new NullPointerException("localNetworkSiteName");
        }
        if (parameters == null) {
            throw new NullPointerException("parameters");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("localNetworkSiteName", localNetworkSiteName);
            tracingParameters.put("parameters", parameters);
            CloudTracing.enter(invocationId, this, "beginConnectDisconnectOrTestingAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway/connection/" + localNetworkSiteName.trim();
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("PUT");
        httpRequest.setDoOutput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Serialize Request
        String requestContent = null;
        XmlSerializer xmlSerializer = Xml.newSerializer();
        StringWriter stringWriter = new StringWriter();
        xmlSerializer.setOutput(stringWriter);
        xmlSerializer.startDocument("UTF-8", true);
        
        xmlSerializer.startTag("http://schemas.microsoft.com/windowsazure", "UpdateConnection");
        
        xmlSerializer.startTag("http://schemas.microsoft.com/windowsazure", "Operation");
        xmlSerializer.text(parameters.getOperation().toString());
        xmlSerializer.endTag("http://schemas.microsoft.com/windowsazure", "Operation");
        
        if (parameters.getIPAddress() != null) {
            xmlSerializer.startTag("http://schemas.microsoft.com/windowsazure", "IPAddress");
            xmlSerializer.text(parameters.getIPAddress().getHostAddress());
            xmlSerializer.endTag("http://schemas.microsoft.com/windowsazure", "IPAddress");
        }
        xmlSerializer.endTag("http://schemas.microsoft.com/windowsazure", "UpdateConnection");
        xmlSerializer.endDocument();
        
        requestContent = stringWriter.toString();
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        
        // Send Request
        try {
            httpRequest.setFixedLengthStreamingMode(requestContent.getBytes().length);
            httpRequest.getOutputStream().write(requestContent.getBytes());
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.ACCEPTED) {
                ServiceException ex = ServiceException.createFromXml(requestContent, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayOperationResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayOperationResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                String idInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    idInstance = xmlPullParser.getText();
                                    result.setOperationId(idInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The Begin Creating Virtual network Gateway operation creates a new
    * network gateway for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154119.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param parameters Required. Parameters supplied to the Begin Creating
    * Virtual Network Gateway operation.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public Future<GatewayOperationResponse> beginCreatingAsync(final String networkName, final GatewayCreateParameters parameters) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayOperationResponse>() { 
            @Override
            public GatewayOperationResponse call() throws Exception {
                return beginCreating(networkName, parameters);
            }
         });
    }
    
    /**
    * The Begin Creating Virtual network Gateway operation creates a new
    * network gateway for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154119.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param parameters Required. Parameters supplied to the Begin Creating
    * Virtual Network Gateway operation.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public GatewayOperationResponse beginCreating(String networkName, GatewayCreateParameters parameters) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        if (parameters == null) {
            throw new NullPointerException("parameters");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("parameters", parameters);
            CloudTracing.enter(invocationId, this, "beginCreatingAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway";
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("POST");
        httpRequest.setDoOutput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Serialize Request
        String requestContent = null;
        XmlSerializer xmlSerializer = Xml.newSerializer();
        StringWriter stringWriter = new StringWriter();
        xmlSerializer.setOutput(stringWriter);
        xmlSerializer.startDocument("UTF-8", true);
        
        xmlSerializer.startTag("http://schemas.microsoft.com/windowsazure", "CreateGatewayParameters");
        
        xmlSerializer.startTag("http://schemas.microsoft.com/windowsazure", "GatewayType");
        xmlSerializer.text(parameters.getGatewayType().toString());
        xmlSerializer.endTag("http://schemas.microsoft.com/windowsazure", "GatewayType");
        xmlSerializer.endTag("http://schemas.microsoft.com/windowsazure", "CreateGatewayParameters");
        xmlSerializer.endDocument();
        
        requestContent = stringWriter.toString();
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        
        // Send Request
        try {
            httpRequest.setFixedLengthStreamingMode(requestContent.getBytes().length);
            httpRequest.getOutputStream().write(requestContent.getBytes());
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.CREATED) {
                ServiceException ex = ServiceException.createFromXml(requestContent, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayOperationResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayOperationResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                String idInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    idInstance = xmlPullParser.getText();
                                    result.setOperationId(idInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The Begin Deleting Virtual Network Gateway operation deletes a network
    * gateway for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154129.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public Future<GatewayOperationResponse> beginDeletingAsync(final String networkName) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayOperationResponse>() { 
            @Override
            public GatewayOperationResponse call() throws Exception {
                return beginDeleting(networkName);
            }
         });
    }
    
    /**
    * The Begin Deleting Virtual Network Gateway operation deletes a network
    * gateway for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154129.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public GatewayOperationResponse beginDeleting(String networkName) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            CloudTracing.enter(invocationId, this, "beginDeletingAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway";
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("DELETE");
        
        // Set Headers
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Send Request
        try {
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.ACCEPTED) {
                ServiceException ex = ServiceException.createFromXml(null, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayOperationResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayOperationResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                String idInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    idInstance = xmlPullParser.getText();
                                    result.setOperationId(idInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The Begin Failover Virtual Network Gateway operation causes a network
    * gateway failover for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154118.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network in Azure.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public Future<GatewayOperationResponse> beginFailoverAsync(final String networkName) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayOperationResponse>() { 
            @Override
            public GatewayOperationResponse call() throws Exception {
                return beginFailover(networkName);
            }
         });
    }
    
    /**
    * The Begin Failover Virtual Network Gateway operation causes a network
    * gateway failover for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154118.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network in Azure.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public GatewayOperationResponse beginFailover(String networkName) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            CloudTracing.enter(invocationId, this, "beginFailoverAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway";
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("DELETE");
        
        // Set Headers
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Serialize Request
        String requestContent = "<" + "?" + "xml version=\"1.0\" encoding=\"utf-8\"" + "?" + "><UpdateGateway xmlns=\"http://schemas.microsoft.com/windowsazure\"><UpdateGatewayOperation>Failover</UpdateGatewayOperation></UpdateGateway>";
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        
        // Send Request
        try {
            httpRequest.setFixedLengthStreamingMode(requestContent.getBytes().length);
            httpRequest.getOutputStream().write(requestContent.getBytes());
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.ACCEPTED) {
                ServiceException ex = ServiceException.createFromXml(requestContent, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayOperationResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayOperationResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                String idInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    idInstance = xmlPullParser.getText();
                                    result.setOperationId(idInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The Begin Reset Virtual Network Gateway Shared Key operation resets the
    * shared key on the virtual network gateway for the specified virtual
    * network connection to the specified local network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154114.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkName Required. The name of the local network.
    * @param parameters Required. Parameters supplied to the Begin Virtual
    * Network Gateway Reset Shared Key request.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public Future<GatewayOperationResponse> beginResetSharedKeyAsync(final String networkName, final String localNetworkName, final GatewayResetSharedKeyParameters parameters) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayOperationResponse>() { 
            @Override
            public GatewayOperationResponse call() throws Exception {
                return beginResetSharedKey(networkName, localNetworkName, parameters);
            }
         });
    }
    
    /**
    * The Begin Reset Virtual Network Gateway Shared Key operation resets the
    * shared key on the virtual network gateway for the specified virtual
    * network connection to the specified local network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154114.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkName Required. The name of the local network.
    * @param parameters Required. Parameters supplied to the Begin Virtual
    * Network Gateway Reset Shared Key request.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public GatewayOperationResponse beginResetSharedKey(String networkName, String localNetworkName, GatewayResetSharedKeyParameters parameters) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        if (localNetworkName == null) {
            throw new NullPointerException("localNetworkName");
        }
        if (parameters == null) {
            throw new NullPointerException("parameters");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("localNetworkName", localNetworkName);
            tracingParameters.put("parameters", parameters);
            CloudTracing.enter(invocationId, this, "beginResetSharedKeyAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway/connection/" + localNetworkName.trim() + "/sharedkey";
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("PUT");
        httpRequest.setDoOutput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Serialize Request
        String requestContent = null;
        XmlSerializer xmlSerializer = Xml.newSerializer();
        StringWriter stringWriter = new StringWriter();
        xmlSerializer.setOutput(stringWriter);
        xmlSerializer.startDocument("UTF-8", true);
        
        xmlSerializer.startTag("http://schemas.microsoft.com/windowsazure", "ResetSharedKey");
        
        xmlSerializer.startTag("http://schemas.microsoft.com/windowsazure", "KeyLength");
        xmlSerializer.text(Integer.toString(parameters.getKeyLength()));
        xmlSerializer.endTag("http://schemas.microsoft.com/windowsazure", "KeyLength");
        xmlSerializer.endTag("http://schemas.microsoft.com/windowsazure", "ResetSharedKey");
        xmlSerializer.endDocument();
        
        requestContent = stringWriter.toString();
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        
        // Send Request
        try {
            httpRequest.setFixedLengthStreamingMode(requestContent.getBytes().length);
            httpRequest.getOutputStream().write(requestContent.getBytes());
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.ACCEPTED) {
                ServiceException ex = ServiceException.createFromXml(requestContent, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayOperationResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayOperationResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                String idInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    idInstance = xmlPullParser.getText();
                                    result.setOperationId(idInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The Begin Set Virtual Network Gateway Shared Key operation sets the
    * shared key on the virtual network gateway for the specified virtual
    * network connection to the specified local network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154114.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkName Required. The name of the local network.
    * @param parameters Required. Parameters supplied to the Begin Virtual
    * Network Gateway Set Shared Key request.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public Future<GatewayOperationResponse> beginSetSharedKeyAsync(final String networkName, final String localNetworkName, final GatewaySetSharedKeyParameters parameters) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayOperationResponse>() { 
            @Override
            public GatewayOperationResponse call() throws Exception {
                return beginSetSharedKey(networkName, localNetworkName, parameters);
            }
         });
    }
    
    /**
    * The Begin Set Virtual Network Gateway Shared Key operation sets the
    * shared key on the virtual network gateway for the specified virtual
    * network connection to the specified local network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154114.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkName Required. The name of the local network.
    * @param parameters Required. Parameters supplied to the Begin Virtual
    * Network Gateway Set Shared Key request.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public GatewayOperationResponse beginSetSharedKey(String networkName, String localNetworkName, GatewaySetSharedKeyParameters parameters) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        if (localNetworkName == null) {
            throw new NullPointerException("localNetworkName");
        }
        if (parameters == null) {
            throw new NullPointerException("parameters");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("localNetworkName", localNetworkName);
            tracingParameters.put("parameters", parameters);
            CloudTracing.enter(invocationId, this, "beginSetSharedKeyAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway/connection/" + localNetworkName.trim() + "/sharedkey";
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("POST");
        httpRequest.setDoOutput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Serialize Request
        String requestContent = null;
        XmlSerializer xmlSerializer = Xml.newSerializer();
        StringWriter stringWriter = new StringWriter();
        xmlSerializer.setOutput(stringWriter);
        xmlSerializer.startDocument("UTF-8", true);
        
        xmlSerializer.startTag("http://schemas.microsoft.com/windowsazure", "SharedKey");
        
        if (parameters.getValue() != null) {
            xmlSerializer.startTag("http://schemas.microsoft.com/windowsazure", "Value");
            xmlSerializer.text(parameters.getValue());
            xmlSerializer.endTag("http://schemas.microsoft.com/windowsazure", "Value");
        }
        xmlSerializer.endTag("http://schemas.microsoft.com/windowsazure", "SharedKey");
        xmlSerializer.endDocument();
        
        requestContent = stringWriter.toString();
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        
        // Send Request
        try {
            httpRequest.setFixedLengthStreamingMode(requestContent.getBytes().length);
            httpRequest.getOutputStream().write(requestContent.getBytes());
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.ACCEPTED) {
                ServiceException ex = ServiceException.createFromXml(requestContent, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayOperationResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayOperationResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                String idInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    idInstance = xmlPullParser.getText();
                                    result.setOperationId(idInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * To connect to, disconnect from, or test your connection to a local
    * network site, access the connection resource representing the local
    * network and specify Connect, Disconnect or Test to perform the desired
    * operation.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154107.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkSiteName Required. The name of the site to connect to.
    * @param parameters Required. Parameters supplied to the Connect Disconnect
    * Or Testing Gateway operation.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public Future<GatewayGetOperationStatusResponse> connectDisconnectOrTestAsync(final String networkName, final String localNetworkSiteName, final GatewayConnectDisconnectOrTestParameters parameters) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayGetOperationStatusResponse>() { 
            @Override
            public GatewayGetOperationStatusResponse call() throws Exception {
                return connectDisconnectOrTest(networkName, localNetworkSiteName, parameters);
            }
         });
    }
    
    /**
    * To connect to, disconnect from, or test your connection to a local
    * network site, access the connection resource representing the local
    * network and specify Connect, Disconnect or Test to perform the desired
    * operation.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154107.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkSiteName Required. The name of the site to connect to.
    * @param parameters Required. Parameters supplied to the Connect Disconnect
    * Or Testing Gateway operation.
    * @throws InterruptedException Thrown when a thread is waiting, sleeping,
    * or otherwise occupied, and the thread is interrupted, either before or
    * during the activity. Occasionally a method may wish to test whether the
    * current thread has been interrupted, and if so, to immediately throw
    * this exception. The following code can be used to achieve this effect:
    * @throws ExecutionException Thrown when attempting to retrieve the result
    * of a task that aborted by throwing an exception. This exception can be
    * inspected using the Throwable.getCause() method.
    * @throws ServiceException Thrown if the server returned an error for the
    * request.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public GatewayGetOperationStatusResponse connectDisconnectOrTest(String networkName, String localNetworkSiteName, GatewayConnectDisconnectOrTestParameters parameters) throws InterruptedException, ExecutionException, ServiceException {
        NetworkManagementClient client2 = this.getClient();
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("localNetworkSiteName", localNetworkSiteName);
            tracingParameters.put("parameters", parameters);
            CloudTracing.enter(invocationId, this, "connectDisconnectOrTestAsync", tracingParameters);
        }
        if (shouldTrace) {
            client2 = this.getClient().withRequestFilterLast(new ClientRequestTrackingHandler(invocationId)).withResponseFilterLast(new ClientRequestTrackingHandler(invocationId));
        }
        
        GatewayOperationResponse response = client2.getGatewaysOperations().beginConnectDisconnectOrTestingAsync(networkName, localNetworkSiteName, parameters).get();
        GatewayGetOperationStatusResponse result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
        int delayInSeconds = 30;
        while ((result.getStatus() != GatewayOperationStatus.InProgress) == false) {
            Thread.sleep(delayInSeconds * 1000);
            result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
            delayInSeconds = 30;
        }
        
        if (shouldTrace) {
            CloudTracing.exit(invocationId, result);
        }
        
        if (result.getStatus() != GatewayOperationStatus.Successful) {
            if (result.getError() != null) {
                ServiceException ex = new ServiceException(result.getError().getCode() + " : " + result.getError().getMessage());
                ex.setErrorCode(result.getError().getCode());
                ex.setErrorMessage(result.getError().getMessage());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            } else {
                ServiceException ex = new ServiceException("");
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
        }
        
        return result;
    }
    
    /**
    * The Create Virtual network Gateway operation creates a new network
    * gateway for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154119.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param parameters Required. Parameters supplied to the Create Virtual
    * Network Gateway operation.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public Future<GatewayGetOperationStatusResponse> createAsync(final String networkName, final GatewayCreateParameters parameters) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayGetOperationStatusResponse>() { 
            @Override
            public GatewayGetOperationStatusResponse call() throws Exception {
                return create(networkName, parameters);
            }
         });
    }
    
    /**
    * The Create Virtual network Gateway operation creates a new network
    * gateway for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154119.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param parameters Required. Parameters supplied to the Create Virtual
    * Network Gateway operation.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @throws InterruptedException Thrown when a thread is waiting, sleeping,
    * or otherwise occupied, and the thread is interrupted, either before or
    * during the activity. Occasionally a method may wish to test whether the
    * current thread has been interrupted, and if so, to immediately throw
    * this exception. The following code can be used to achieve this effect:
    * @throws ExecutionException Thrown when attempting to retrieve the result
    * of a task that aborted by throwing an exception. This exception can be
    * inspected using the Throwable.getCause() method.
    * @throws ServiceException Thrown if the server returned an error for the
    * request.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public GatewayGetOperationStatusResponse create(String networkName, GatewayCreateParameters parameters) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException, InterruptedException, ExecutionException {
        NetworkManagementClient client2 = this.getClient();
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("parameters", parameters);
            CloudTracing.enter(invocationId, this, "createAsync", tracingParameters);
        }
        if (shouldTrace) {
            client2 = this.getClient().withRequestFilterLast(new ClientRequestTrackingHandler(invocationId)).withResponseFilterLast(new ClientRequestTrackingHandler(invocationId));
        }
        
        GatewayOperationResponse response = client2.getGatewaysOperations().beginCreatingAsync(networkName, parameters).get();
        GatewayGetOperationStatusResponse result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
        int delayInSeconds = 30;
        while ((result.getStatus() != GatewayOperationStatus.InProgress) == false) {
            Thread.sleep(delayInSeconds * 1000);
            result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
            delayInSeconds = 30;
        }
        
        if (shouldTrace) {
            CloudTracing.exit(invocationId, result);
        }
        
        if (result.getStatus() != GatewayOperationStatus.Successful) {
            if (result.getError() != null) {
                ServiceException ex = new ServiceException(result.getError().getCode() + " : " + result.getError().getMessage());
                ex.setErrorCode(result.getError().getCode());
                ex.setErrorMessage(result.getError().getMessage());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            } else {
                ServiceException ex = new ServiceException("");
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
        }
        
        return result;
    }
    
    /**
    * The Delete Virtual Network Gateway operation deletes a network gateway
    * for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154129.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public Future<GatewayGetOperationStatusResponse> deleteAsync(final String networkName) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayGetOperationStatusResponse>() { 
            @Override
            public GatewayGetOperationStatusResponse call() throws Exception {
                return delete(networkName);
            }
         });
    }
    
    /**
    * The Delete Virtual Network Gateway operation deletes a network gateway
    * for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154129.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @throws InterruptedException Thrown when a thread is waiting, sleeping,
    * or otherwise occupied, and the thread is interrupted, either before or
    * during the activity. Occasionally a method may wish to test whether the
    * current thread has been interrupted, and if so, to immediately throw
    * this exception. The following code can be used to achieve this effect:
    * @throws ExecutionException Thrown when attempting to retrieve the result
    * of a task that aborted by throwing an exception. This exception can be
    * inspected using the Throwable.getCause() method.
    * @throws ServiceException Thrown if the server returned an error for the
    * request.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public GatewayGetOperationStatusResponse delete(String networkName) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException, InterruptedException, ExecutionException {
        NetworkManagementClient client2 = this.getClient();
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            CloudTracing.enter(invocationId, this, "deleteAsync", tracingParameters);
        }
        if (shouldTrace) {
            client2 = this.getClient().withRequestFilterLast(new ClientRequestTrackingHandler(invocationId)).withResponseFilterLast(new ClientRequestTrackingHandler(invocationId));
        }
        
        GatewayOperationResponse response = client2.getGatewaysOperations().beginDeletingAsync(networkName).get();
        GatewayGetOperationStatusResponse result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
        int delayInSeconds = 30;
        while ((result.getStatus() != GatewayOperationStatus.InProgress) == false) {
            Thread.sleep(delayInSeconds * 1000);
            result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
            delayInSeconds = 30;
        }
        
        if (shouldTrace) {
            CloudTracing.exit(invocationId, result);
        }
        
        if (result.getStatus() != GatewayOperationStatus.Successful) {
            if (result.getError() != null) {
                ServiceException ex = new ServiceException(result.getError().getCode() + " : " + result.getError().getMessage());
                ex.setErrorCode(result.getError().getCode());
                ex.setErrorMessage(result.getError().getMessage());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            } else {
                ServiceException ex = new ServiceException("");
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
        }
        
        return result;
    }
    
    /**
    * The Failover Virtual Network Gateway operation causes a network gateway
    * failover for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154118.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network in Azure.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public Future<GatewayGetOperationStatusResponse> failoverAsync(final String networkName) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayGetOperationStatusResponse>() { 
            @Override
            public GatewayGetOperationStatusResponse call() throws Exception {
                return failover(networkName);
            }
         });
    }
    
    /**
    * The Failover Virtual Network Gateway operation causes a network gateway
    * failover for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154118.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network in Azure.
    * @throws InterruptedException Thrown when a thread is waiting, sleeping,
    * or otherwise occupied, and the thread is interrupted, either before or
    * during the activity. Occasionally a method may wish to test whether the
    * current thread has been interrupted, and if so, to immediately throw
    * this exception. The following code can be used to achieve this effect:
    * @throws ExecutionException Thrown when attempting to retrieve the result
    * of a task that aborted by throwing an exception. This exception can be
    * inspected using the Throwable.getCause() method.
    * @throws ServiceException Thrown if the server returned an error for the
    * request.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public GatewayGetOperationStatusResponse failover(String networkName) throws InterruptedException, ExecutionException, ServiceException {
        NetworkManagementClient client2 = this.getClient();
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            CloudTracing.enter(invocationId, this, "failoverAsync", tracingParameters);
        }
        if (shouldTrace) {
            client2 = this.getClient().withRequestFilterLast(new ClientRequestTrackingHandler(invocationId)).withResponseFilterLast(new ClientRequestTrackingHandler(invocationId));
        }
        
        GatewayOperationResponse response = client2.getGatewaysOperations().beginFailoverAsync(networkName).get();
        GatewayGetOperationStatusResponse result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
        int delayInSeconds = 30;
        while ((result.getStatus() != GatewayOperationStatus.InProgress) == false) {
            Thread.sleep(delayInSeconds * 1000);
            result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
            delayInSeconds = 30;
        }
        
        if (shouldTrace) {
            CloudTracing.exit(invocationId, result);
        }
        
        if (result.getStatus() != GatewayOperationStatus.Successful) {
            if (result.getError() != null) {
                ServiceException ex = new ServiceException(result.getError().getCode() + " : " + result.getError().getMessage());
                ex.setErrorCode(result.getError().getCode());
                ex.setErrorMessage(result.getError().getMessage());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            } else {
                ServiceException ex = new ServiceException("");
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
        }
        
        return result;
    }
    
    /**
    * The Generate VPN Client Package operation creates a VPN client package
    * for the specified virtual network and gateway in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/dn205126.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param parameters Required. Parameters supplied to the Generate VPN
    * Client Package operation.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public Future<GatewayOperationResponse> generateVpnClientPackageAsync(final String networkName, final GatewayGenerateVpnClientPackageParameters parameters) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayOperationResponse>() { 
            @Override
            public GatewayOperationResponse call() throws Exception {
                return generateVpnClientPackage(networkName, parameters);
            }
         });
    }
    
    /**
    * The Generate VPN Client Package operation creates a VPN client package
    * for the specified virtual network and gateway in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/dn205126.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param parameters Required. Parameters supplied to the Generate VPN
    * Client Package operation.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public GatewayOperationResponse generateVpnClientPackage(String networkName, GatewayGenerateVpnClientPackageParameters parameters) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        if (parameters == null) {
            throw new NullPointerException("parameters");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("parameters", parameters);
            CloudTracing.enter(invocationId, this, "generateVpnClientPackageAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway/vpnclientpackage";
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("POST");
        httpRequest.setDoOutput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Serialize Request
        String requestContent = null;
        XmlSerializer xmlSerializer = Xml.newSerializer();
        StringWriter stringWriter = new StringWriter();
        xmlSerializer.setOutput(stringWriter);
        xmlSerializer.startDocument("UTF-8", true);
        
        xmlSerializer.startTag("", "VpnClientParameters");
        
        xmlSerializer.startTag("", "ProcessorArchitecture");
        xmlSerializer.text(parameters.getProcessorArchitecture().toString());
        xmlSerializer.endTag("", "ProcessorArchitecture");
        xmlSerializer.endTag("", "VpnClientParameters");
        xmlSerializer.endDocument();
        
        requestContent = stringWriter.toString();
        httpRequest.setRequestProperty("Content-Type", "application/xml");
        
        // Send Request
        try {
            httpRequest.setFixedLengthStreamingMode(requestContent.getBytes().length);
            httpRequest.getOutputStream().write(requestContent.getBytes());
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.CREATED) {
                ServiceException ex = ServiceException.createFromXml(requestContent, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayOperationResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayOperationResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "GatewayOperationAsyncResponse".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                String idInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    idInstance = xmlPullParser.getText();
                                    result.setOperationId(idInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The Get Virtual Network Gateway operation gets information about the
    * network gateway for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154109.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public Future<GatewayGetResponse> getAsync(final String networkName) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayGetResponse>() { 
            @Override
            public GatewayGetResponse call() throws Exception {
                return get(networkName);
            }
         });
    }
    
    /**
    * The Get Virtual Network Gateway operation gets information about the
    * network gateway for the specified virtual network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154109.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public GatewayGetResponse get(String networkName) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            CloudTracing.enter(invocationId, this, "getAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway";
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("GET");
        httpRequest.setDoInput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Send Request
        try {
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.OK) {
                ServiceException ex = ServiceException.createFromXml(null, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayGetResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayGetResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "Gateway".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "Gateway".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "State".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "State".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                String stateInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    stateInstance = xmlPullParser.getText();
                                    result.setState(stateInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        if (eventType == XmlPullParser.START_TAG && "VIPAddress".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "VIPAddress".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                InetAddress vIPAddressInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    vIPAddressInstance = InetAddress.getByName(xmlPullParser.getText());
                                    result.setVipAddress(vIPAddressInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        if (eventType == XmlPullParser.START_TAG && "LastEvent".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "LastEvent".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                GatewayEvent lastEventInstance = new GatewayEvent();
                                result.setLastEvent(lastEventInstance);
                                
                                if (eventType == XmlPullParser.START_TAG && "Timestamp".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                    while ((eventType == XmlPullParser.END_TAG && "Timestamp".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                        Calendar timestampInstance;
                                        if (eventType == XmlPullParser.TEXT) {
                                            timestampInstance = DatatypeConverter.parseDateTime(xmlPullParser.getText());
                                            lastEventInstance.setTimestamp(timestampInstance);
                                        }
                                        
                                        eventType = xmlPullParser.next();
                                    }
                                }
                                
                                if (eventType == XmlPullParser.START_TAG && "Id".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                    while ((eventType == XmlPullParser.END_TAG && "Id".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                        String idInstance;
                                        if (eventType == XmlPullParser.TEXT) {
                                            idInstance = xmlPullParser.getText();
                                            lastEventInstance.setId(idInstance);
                                        }
                                        
                                        eventType = xmlPullParser.next();
                                    }
                                }
                                
                                if (eventType == XmlPullParser.START_TAG && "Message".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                    while ((eventType == XmlPullParser.END_TAG && "Message".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                        String messageInstance;
                                        if (eventType == XmlPullParser.TEXT) {
                                            messageInstance = xmlPullParser.getText();
                                            lastEventInstance.setMessage(messageInstance);
                                        }
                                        
                                        eventType = xmlPullParser.next();
                                    }
                                }
                                
                                if (eventType == XmlPullParser.START_TAG && "Data".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                    while ((eventType == XmlPullParser.END_TAG && "Data".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                        String dataInstance;
                                        if (eventType == XmlPullParser.TEXT) {
                                            dataInstance = xmlPullParser.getText();
                                            lastEventInstance.setData(dataInstance);
                                        }
                                        
                                        eventType = xmlPullParser.next();
                                    }
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        if (eventType == XmlPullParser.START_TAG && "GatewayType".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "GatewayType".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                GatewayType gatewayTypeInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    gatewayTypeInstance = GatewayType.valueOf(xmlPullParser.getText());
                                    result.setGatewayType(gatewayTypeInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The Get Device Configuration Script operation returns a script that you
    * can use to configure local VPN devices to connect to the gateway.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154115.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param parameters Required. The parameters for the Get Device
    * Configuration Script operation.
    * @return The configuration script returned from the get device
    * configuration script operation.
    */
    @Override
    public Future<GatewayGetDeviceConfigurationScriptResponse> getDeviceConfigurationScriptAsync(final String networkName, final GatewayGetDeviceConfigurationScriptParameters parameters) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayGetDeviceConfigurationScriptResponse>() { 
            @Override
            public GatewayGetDeviceConfigurationScriptResponse call() throws Exception {
                return getDeviceConfigurationScript(networkName, parameters);
            }
         });
    }
    
    /**
    * The Get Device Configuration Script operation returns a script that you
    * can use to configure local VPN devices to connect to the gateway.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154115.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param parameters Required. The parameters for the Get Device
    * Configuration Script operation.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @return The configuration script returned from the get device
    * configuration script operation.
    */
    @Override
    public GatewayGetDeviceConfigurationScriptResponse getDeviceConfigurationScript(String networkName, GatewayGetDeviceConfigurationScriptParameters parameters) throws MalformedURLException, ProtocolException, ServiceException, IOException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        if (parameters == null) {
            throw new NullPointerException("parameters");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("parameters", parameters);
            CloudTracing.enter(invocationId, this, "getDeviceConfigurationScriptAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway/vpndeviceconfigurationscript" + "?";
        if (parameters.getVendor() != null) {
            url = url + "vendor=" + URLEncoder.encode(parameters.getVendor() != null ? parameters.getVendor().trim() : "", "UTF-8");
        }
        if (parameters.getPlatform() != null) {
            url = url + "&" + "platform=" + URLEncoder.encode(parameters.getPlatform() != null ? parameters.getPlatform().trim() : "", "UTF-8");
        }
        if (parameters.getOSFamily() != null) {
            url = url + "&" + "OSfamily=" + URLEncoder.encode(parameters.getOSFamily() != null ? parameters.getOSFamily().trim() : "", "UTF-8");
        }
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("GET");
        httpRequest.setDoInput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Send Request
        try {
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.OK) {
                ServiceException ex = ServiceException.createFromXml(null, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayGetDeviceConfigurationScriptResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayGetDeviceConfigurationScriptResponse();
            result.setConfigurationScript(StreamUtils.toString(responseContent));
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The Get Virtual Network Gateway Operation Status gets information on the
    * status of network gateway operations in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154112.aspx for
    * more information)
    *
    * @param operationId Required. The ID of the network operation.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public Future<GatewayGetOperationStatusResponse> getOperationStatusAsync(final String operationId) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayGetOperationStatusResponse>() { 
            @Override
            public GatewayGetOperationStatusResponse call() throws Exception {
                return getOperationStatus(operationId);
            }
         });
    }
    
    /**
    * The Get Virtual Network Gateway Operation Status gets information on the
    * status of network gateway operations in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154112.aspx for
    * more information)
    *
    * @param operationId Required. The ID of the network operation.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public GatewayGetOperationStatusResponse getOperationStatus(String operationId) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (operationId == null) {
            throw new NullPointerException("operationId");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("operationId", operationId);
            CloudTracing.enter(invocationId, this, "getOperationStatusAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/operation/" + operationId.trim();
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("GET");
        httpRequest.setDoInput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Send Request
        try {
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.OK) {
                ServiceException ex = ServiceException.createFromXml(null, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayGetOperationStatusResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayGetOperationStatusResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "GatewayOperation".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "GatewayOperation".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "ID".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                String idInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    idInstance = xmlPullParser.getText();
                                    result.setId(idInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        if (eventType == XmlPullParser.START_TAG && "Status".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "Status".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                GatewayOperationStatus statusInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    statusInstance = GatewayOperationStatus.valueOf(xmlPullParser.getText());
                                    result.setStatus(statusInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        if (eventType == XmlPullParser.START_TAG && "HttpStatusCode".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "HttpStatusCode".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                Integer httpStatusCodeInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    httpStatusCodeInstance = Integer.valueOf(xmlPullParser.getText());
                                    result.setHttpStatusCode(httpStatusCodeInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        if (eventType == XmlPullParser.START_TAG && "Error".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "Error".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                GatewayGetOperationStatusResponse.ErrorDetails errorInstance = new GatewayGetOperationStatusResponse.ErrorDetails();
                                result.setError(errorInstance);
                                
                                if (eventType == XmlPullParser.START_TAG && "Code".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                    while ((eventType == XmlPullParser.END_TAG && "Code".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                        String codeInstance;
                                        if (eventType == XmlPullParser.TEXT) {
                                            codeInstance = xmlPullParser.getText();
                                            errorInstance.setCode(codeInstance);
                                        }
                                        
                                        eventType = xmlPullParser.next();
                                    }
                                }
                                
                                if (eventType == XmlPullParser.START_TAG && "Message".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                    while ((eventType == XmlPullParser.END_TAG && "Message".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                        String messageInstance;
                                        if (eventType == XmlPullParser.TEXT) {
                                            messageInstance = xmlPullParser.getText();
                                            errorInstance.setMessage(messageInstance);
                                        }
                                        
                                        eventType = xmlPullParser.next();
                                    }
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The Get Virtual Network Gateway Shared Key operation gets the shared key
    * on the virtual network gateway for the specified virtual network
    * connection to the specified local network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154122.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkName Required. The name of the local network.
    * @return The response to the get shared key request.
    */
    @Override
    public Future<GatewayGetSharedKeyResponse> getSharedKeyAsync(final String networkName, final String localNetworkName) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayGetSharedKeyResponse>() { 
            @Override
            public GatewayGetSharedKeyResponse call() throws Exception {
                return getSharedKey(networkName, localNetworkName);
            }
         });
    }
    
    /**
    * The Get Virtual Network Gateway Shared Key operation gets the shared key
    * on the virtual network gateway for the specified virtual network
    * connection to the specified local network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154122.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkName Required. The name of the local network.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return The response to the get shared key request.
    */
    @Override
    public GatewayGetSharedKeyResponse getSharedKey(String networkName, String localNetworkName) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        if (localNetworkName == null) {
            throw new NullPointerException("localNetworkName");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("localNetworkName", localNetworkName);
            CloudTracing.enter(invocationId, this, "getSharedKeyAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway/connection/" + localNetworkName.trim() + "/sharedkey";
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("GET");
        httpRequest.setDoInput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Send Request
        try {
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.OK) {
                ServiceException ex = ServiceException.createFromXml(null, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayGetSharedKeyResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayGetSharedKeyResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "SharedKey".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "SharedKey".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "Value".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "Value".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                String valueInstance;
                                if (eventType == XmlPullParser.TEXT) {
                                    valueInstance = xmlPullParser.getText();
                                    result.setSharedKey(valueInstance);
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The List Connections operation returns a list of the local network
    * connections that can be accessed through the gateway.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154120.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @return The response to a ListConnections request to a Virtual Network
    * Gateway.
    */
    @Override
    public Future<GatewayListConnectionsResponse> listConnectionsAsync(final String networkName) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayListConnectionsResponse>() { 
            @Override
            public GatewayListConnectionsResponse call() throws Exception {
                return listConnections(networkName);
            }
         });
    }
    
    /**
    * The List Connections operation returns a list of the local network
    * connections that can be accessed through the gateway.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154120.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return The response to a ListConnections request to a Virtual Network
    * Gateway.
    */
    @Override
    public GatewayListConnectionsResponse listConnections(String networkName) throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        if (networkName == null) {
            throw new NullPointerException("networkName");
        }
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            CloudTracing.enter(invocationId, this, "listConnectionsAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/" + networkName.trim() + "/gateway/connections";
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("GET");
        httpRequest.setDoInput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Send Request
        try {
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.OK) {
                ServiceException ex = ServiceException.createFromXml(null, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayListConnectionsResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayListConnectionsResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "Connections".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "Connections".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                        if (eventType == XmlPullParser.START_TAG && "Connection".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                            GatewayListConnectionsResponse.GatewayConnection connectionInstance = new GatewayListConnectionsResponse.GatewayConnection();
                            result.getConnections().add(connectionInstance);
                            
                            if (eventType == XmlPullParser.START_TAG && "LocalNetworkSiteName".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                while ((eventType == XmlPullParser.END_TAG && "LocalNetworkSiteName".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                    String localNetworkSiteNameInstance;
                                    if (eventType == XmlPullParser.TEXT) {
                                        localNetworkSiteNameInstance = xmlPullParser.getText();
                                        connectionInstance.setLocalNetworkSiteName(localNetworkSiteNameInstance);
                                    }
                                    
                                    eventType = xmlPullParser.next();
                                }
                            }
                            
                            if (eventType == XmlPullParser.START_TAG && "ConnectivityState".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                while ((eventType == XmlPullParser.END_TAG && "ConnectivityState".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                    GatewayConnectivityState connectivityStateInstance;
                                    if (eventType == XmlPullParser.TEXT) {
                                        connectivityStateInstance = GatewayConnectivityState.valueOf(xmlPullParser.getText());
                                        connectionInstance.setConnectivityState(connectivityStateInstance);
                                    }
                                    
                                    eventType = xmlPullParser.next();
                                }
                            }
                            
                            if (eventType == XmlPullParser.START_TAG && "LastEvent".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                while ((eventType == XmlPullParser.END_TAG && "LastEvent".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                    GatewayEvent lastEventInstance = new GatewayEvent();
                                    connectionInstance.setLastEvent(lastEventInstance);
                                    
                                    if (eventType == XmlPullParser.START_TAG && "Timestamp".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                        while ((eventType == XmlPullParser.END_TAG && "Timestamp".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                            Calendar timestampInstance;
                                            if (eventType == XmlPullParser.TEXT) {
                                                timestampInstance = DatatypeConverter.parseDateTime(xmlPullParser.getText());
                                                lastEventInstance.setTimestamp(timestampInstance);
                                            }
                                            
                                            eventType = xmlPullParser.next();
                                        }
                                    }
                                    
                                    if (eventType == XmlPullParser.START_TAG && "Id".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                        while ((eventType == XmlPullParser.END_TAG && "Id".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                            String idInstance;
                                            if (eventType == XmlPullParser.TEXT) {
                                                idInstance = xmlPullParser.getText();
                                                lastEventInstance.setId(idInstance);
                                            }
                                            
                                            eventType = xmlPullParser.next();
                                        }
                                    }
                                    
                                    if (eventType == XmlPullParser.START_TAG && "Message".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                        while ((eventType == XmlPullParser.END_TAG && "Message".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                            String messageInstance;
                                            if (eventType == XmlPullParser.TEXT) {
                                                messageInstance = xmlPullParser.getText();
                                                lastEventInstance.setMessage(messageInstance);
                                            }
                                            
                                            eventType = xmlPullParser.next();
                                        }
                                    }
                                    
                                    if (eventType == XmlPullParser.START_TAG && "Data".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                        while ((eventType == XmlPullParser.END_TAG && "Data".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                            String dataInstance;
                                            if (eventType == XmlPullParser.TEXT) {
                                                dataInstance = xmlPullParser.getText();
                                                lastEventInstance.setData(dataInstance);
                                            }
                                            
                                            eventType = xmlPullParser.next();
                                        }
                                    }
                                    
                                    eventType = xmlPullParser.next();
                                }
                            }
                            
                            if (eventType == XmlPullParser.START_TAG && "IngressBytesTransferred".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                while ((eventType == XmlPullParser.END_TAG && "IngressBytesTransferred".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                    long ingressBytesTransferredInstance;
                                    if (eventType == XmlPullParser.TEXT) {
                                        ingressBytesTransferredInstance = DatatypeConverter.parseLong(xmlPullParser.getText());
                                        connectionInstance.setIngressBytesTransferred(ingressBytesTransferredInstance);
                                    }
                                    
                                    eventType = xmlPullParser.next();
                                }
                            }
                            
                            if (eventType == XmlPullParser.START_TAG && "EgressBytesTransferred".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                while ((eventType == XmlPullParser.END_TAG && "EgressBytesTransferred".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                    long egressBytesTransferredInstance;
                                    if (eventType == XmlPullParser.TEXT) {
                                        egressBytesTransferredInstance = DatatypeConverter.parseLong(xmlPullParser.getText());
                                        connectionInstance.setEgressBytesTransferred(egressBytesTransferredInstance);
                                    }
                                    
                                    eventType = xmlPullParser.next();
                                }
                            }
                            
                            if (eventType == XmlPullParser.START_TAG && "LastConnectionEstablished".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                while ((eventType == XmlPullParser.END_TAG && "LastConnectionEstablished".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                    Calendar lastConnectionEstablishedInstance;
                                    if (eventType == XmlPullParser.TEXT) {
                                        lastConnectionEstablishedInstance = DatatypeConverter.parseDateTime(xmlPullParser.getText());
                                        connectionInstance.setLastConnectionEstablished(lastConnectionEstablishedInstance);
                                    }
                                    
                                    eventType = xmlPullParser.next();
                                }
                            }
                            
                            if (eventType == XmlPullParser.START_TAG && "AllocatedIPAddresses".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) {
                                while ((eventType == XmlPullParser.END_TAG && "AllocatedIPAddresses".equals(xmlPullParser.getName()) && "http://schemas.microsoft.com/windowsazure".equals(xmlPullParser.getNamespace())) != true) {
                                    if (eventType == XmlPullParser.TEXT) {
                                        connectionInstance.getAllocatedIPAddresses().add(xmlPullParser.getText());
                                    }
                                    
                                    eventType = xmlPullParser.next();
                                }
                            }
                            
                            eventType = xmlPullParser.next();
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The List Virtual Network Gateway Supported Devices operation lists the
    * supported, on-premise network devices that can connect to the gateway.
    * (see http://msdn.microsoft.com/en-us/library/windowsazure/jj154102.aspx
    * for more information)
    *
    * @return The response to the list supported devices request.
    */
    @Override
    public Future<GatewayListSupportedDevicesResponse> listSupportedDevicesAsync() {
        return this.getClient().getExecutorService().submit(new Callable<GatewayListSupportedDevicesResponse>() { 
            @Override
            public GatewayListSupportedDevicesResponse call() throws Exception {
                return listSupportedDevices();
            }
         });
    }
    
    /**
    * The List Virtual Network Gateway Supported Devices operation lists the
    * supported, on-premise network devices that can connect to the gateway.
    * (see http://msdn.microsoft.com/en-us/library/windowsazure/jj154102.aspx
    * for more information)
    *
    * @throws MalformedURLException Thrown in case of an invalid request URL
    * @throws ProtocolException Thrown if invalid request method
    * @throws ServiceException Thrown if an unexpected response is found.
    * @throws IOException Signals that an I/O exception of some sort has
    * occurred
    * @throws XmlPullParserException This exception is thrown to signal XML
    * Pull Parser related faults.
    * @return The response to the list supported devices request.
    */
    @Override
    public GatewayListSupportedDevicesResponse listSupportedDevices() throws MalformedURLException, ProtocolException, ServiceException, IOException, XmlPullParserException {
        // Validate
        
        // Tracing
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            CloudTracing.enter(invocationId, this, "listSupportedDevicesAsync", tracingParameters);
        }
        
        // Construct URL
        String baseUrl = this.getClient().getBaseUri().toString();
        String url = "/" + (this.getClient().getCredentials().getSubscriptionId() != null ? this.getClient().getCredentials().getSubscriptionId().trim() : "") + "/services/networking/supporteddevices";
        // Trim '/' character from the end of baseUrl and beginning of url.
        if (baseUrl.charAt(baseUrl.length() - 1) == '/') {
            baseUrl = baseUrl.substring(0, (baseUrl.length() - 1) + 0);
        }
        if (url.charAt(0) == '/') {
            url = url.substring(1);
        }
        url = baseUrl + "/" + url;
        
        // Create HTTP transport objects
        URL serverAddress = new URL(url);
        HttpURLConnection httpRequest = ((HttpURLConnection) serverAddress.openConnection());
        httpRequest.setRequestMethod("GET");
        httpRequest.setDoInput(true);
        
        // Set Headers
        httpRequest.setRequestProperty("x-ms-version", "2014-05-01");
        
        // Set Credentials
        this.getClient().getCredentials().processRequest(httpRequest);
        
        // Send Request
        try {
            int statusCode = httpRequest.getResponseCode();
            if (statusCode != AzureHttpStatus.OK) {
                ServiceException ex = ServiceException.createFromXml(null, httpRequest.getResponseMessage(), httpRequest.getResponseCode(), httpRequest.getContentType(), httpRequest.getInputStream());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            GatewayListSupportedDevicesResponse result = null;
            // Deserialize Response
            InputStream responseContent = httpRequest.getInputStream();
            result = new GatewayListSupportedDevicesResponse();
            XmlPullParserFactory xmlPullParserFactory = XmlPullParserFactory.newInstance();
            xmlPullParserFactory.setNamespaceAware(true);
            XmlPullParser xmlPullParser = xmlPullParserFactory.newPullParser();
            xmlPullParser.setInput(new InputStreamReader(new BOMInputStream(responseContent)));
            
            int eventType = xmlPullParser.getEventType();
            while ((eventType == XmlPullParser.END_DOCUMENT) != true) {
                if (eventType == XmlPullParser.START_TAG && "VpnDeviceList".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) {
                    while ((eventType == XmlPullParser.END_TAG && "VpnDeviceList".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) != true) {
                        for (int i = 0; i < xmlPullParser.getAttributeCount(); i = i + 1) {
                            if ("version".equals(xmlPullParser.getAttributeName(i)) && "".equals(xmlPullParser.getAttributeNamespace(i))) {
                                result.setVersion(xmlPullParser.getAttributeValue(i));
                            }
                        }
                        
                        if (eventType == XmlPullParser.START_TAG && "Vendors".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) {
                            while ((eventType == XmlPullParser.END_TAG && "Vendors".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) != true) {
                                if (eventType == XmlPullParser.START_TAG && "Vendor".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) {
                                    GatewayListSupportedDevicesResponse.Vendor vendorInstance = new GatewayListSupportedDevicesResponse.Vendor();
                                    result.getVendors().add(vendorInstance);
                                    for (int i2 = 0; i2 < xmlPullParser.getAttributeCount(); i2 = i2 + 1) {
                                        if ("name".equals(xmlPullParser.getAttributeName(i2)) && "".equals(xmlPullParser.getAttributeNamespace(i2))) {
                                            vendorInstance.setName(xmlPullParser.getAttributeValue(i2));
                                        }
                                    }
                                    
                                    if (eventType == XmlPullParser.START_TAG && "Platforms".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) {
                                        while ((eventType == XmlPullParser.END_TAG && "Platforms".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) != true) {
                                            if (eventType == XmlPullParser.START_TAG && "Platform".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) {
                                                GatewayListSupportedDevicesResponse.Platform platformInstance = new GatewayListSupportedDevicesResponse.Platform();
                                                vendorInstance.getPlatforms().add(platformInstance);
                                                for (int i3 = 0; i3 < xmlPullParser.getAttributeCount(); i3 = i3 + 1) {
                                                    if ("name".equals(xmlPullParser.getAttributeName(i3)) && "".equals(xmlPullParser.getAttributeNamespace(i3))) {
                                                        platformInstance.setName(xmlPullParser.getAttributeValue(i3));
                                                    }
                                                }
                                                
                                                if (eventType == XmlPullParser.START_TAG && "OSFamilies".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) {
                                                    while ((eventType == XmlPullParser.END_TAG && "OSFamilies".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) != true) {
                                                        if (eventType == XmlPullParser.START_TAG && "OSFamily".equals(xmlPullParser.getName()) && "".equals(xmlPullParser.getNamespace())) {
                                                            GatewayListSupportedDevicesResponse.OSFamily oSFamilyInstance = new GatewayListSupportedDevicesResponse.OSFamily();
                                                            platformInstance.getOSFamilies().add(oSFamilyInstance);
                                                            for (int i4 = 0; i4 < xmlPullParser.getAttributeCount(); i4 = i4 + 1) {
                                                                if ("name".equals(xmlPullParser.getAttributeName(i4)) && "".equals(xmlPullParser.getAttributeNamespace(i4))) {
                                                                    oSFamilyInstance.setName(xmlPullParser.getAttributeValue(i4));
                                                                }
                                                            }
                                                            
                                                            eventType = xmlPullParser.next();
                                                        }
                                                        
                                                        eventType = xmlPullParser.next();
                                                    }
                                                }
                                                
                                                eventType = xmlPullParser.next();
                                            }
                                            
                                            eventType = xmlPullParser.next();
                                        }
                                    }
                                    
                                    eventType = xmlPullParser.next();
                                }
                                
                                eventType = xmlPullParser.next();
                            }
                        }
                        
                        eventType = xmlPullParser.next();
                    }
                }
                
                eventType = xmlPullParser.next();
            }
            
            result.setStatusCode(statusCode);
            result.setRequestId(httpRequest.getHeaderField("x-ms-request-id"));
            
            if (shouldTrace) {
                CloudTracing.exit(invocationId, result);
            }
            return result;
        } finally {
            if (httpRequest != null) {
                httpRequest.disconnect();
            }
        }
    }
    
    /**
    * The Reset Virtual Network Gateway Shared Key operation resets the shared
    * key on the virtual network gateway for the specified virtual network
    * connection to the specified local network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154114.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkName Required. The name of the local network.
    * @param parameters Required. The parameters to the Virtual Network Gateway
    * Reset Shared Key request.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public Future<GatewayGetOperationStatusResponse> resetSharedKeyAsync(final String networkName, final String localNetworkName, final GatewayResetSharedKeyParameters parameters) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayGetOperationStatusResponse>() { 
            @Override
            public GatewayGetOperationStatusResponse call() throws Exception {
                return resetSharedKey(networkName, localNetworkName, parameters);
            }
         });
    }
    
    /**
    * The Reset Virtual Network Gateway Shared Key operation resets the shared
    * key on the virtual network gateway for the specified virtual network
    * connection to the specified local network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154114.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkName Required. The name of the local network.
    * @param parameters Required. The parameters to the Virtual Network Gateway
    * Reset Shared Key request.
    * @throws InterruptedException Thrown when a thread is waiting, sleeping,
    * or otherwise occupied, and the thread is interrupted, either before or
    * during the activity. Occasionally a method may wish to test whether the
    * current thread has been interrupted, and if so, to immediately throw
    * this exception. The following code can be used to achieve this effect:
    * @throws ExecutionException Thrown when attempting to retrieve the result
    * of a task that aborted by throwing an exception. This exception can be
    * inspected using the Throwable.getCause() method.
    * @throws ServiceException Thrown if the server returned an error for the
    * request.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public GatewayGetOperationStatusResponse resetSharedKey(String networkName, String localNetworkName, GatewayResetSharedKeyParameters parameters) throws InterruptedException, ExecutionException, ServiceException {
        NetworkManagementClient client2 = this.getClient();
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("localNetworkName", localNetworkName);
            tracingParameters.put("parameters", parameters);
            CloudTracing.enter(invocationId, this, "resetSharedKeyAsync", tracingParameters);
        }
        if (shouldTrace) {
            client2 = this.getClient().withRequestFilterLast(new ClientRequestTrackingHandler(invocationId)).withResponseFilterLast(new ClientRequestTrackingHandler(invocationId));
        }
        
        GatewayOperationResponse response = client2.getGatewaysOperations().beginResetSharedKeyAsync(networkName, localNetworkName, parameters).get();
        GatewayGetOperationStatusResponse result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
        int delayInSeconds = 30;
        while ((result.getStatus() != GatewayOperationStatus.InProgress) == false) {
            Thread.sleep(delayInSeconds * 1000);
            result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
            delayInSeconds = 30;
        }
        
        if (shouldTrace) {
            CloudTracing.exit(invocationId, result);
        }
        
        if (result.getStatus() != GatewayOperationStatus.Successful) {
            if (result.getError() != null) {
                ServiceException ex = new ServiceException(result.getError().getCode() + " : " + result.getError().getMessage());
                ex.setErrorCode(result.getError().getCode());
                ex.setErrorMessage(result.getError().getMessage());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            } else {
                ServiceException ex = new ServiceException("");
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
        }
        
        return result;
    }
    
    /**
    * The Set Virtual Network Gateway Shared Key operation sets the shared key
    * on the virtual network gateway for the specified virtual network
    * connection to the specified local network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154114.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkName Required. The name of the local network.
    * @param parameters Required. The parameters to the Virtual Network Gateway
    * Set Shared Key request.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public Future<GatewayGetOperationStatusResponse> setSharedKeyAsync(final String networkName, final String localNetworkName, final GatewaySetSharedKeyParameters parameters) {
        return this.getClient().getExecutorService().submit(new Callable<GatewayGetOperationStatusResponse>() { 
            @Override
            public GatewayGetOperationStatusResponse call() throws Exception {
                return setSharedKey(networkName, localNetworkName, parameters);
            }
         });
    }
    
    /**
    * The Set Virtual Network Gateway Shared Key operation sets the shared key
    * on the virtual network gateway for the specified virtual network
    * connection to the specified local network in Azure.  (see
    * http://msdn.microsoft.com/en-us/library/windowsazure/jj154114.aspx for
    * more information)
    *
    * @param networkName Required. The name of the virtual network for this
    * gateway.
    * @param localNetworkName Required. The name of the local network.
    * @param parameters Required. The parameters to the Virtual Network Gateway
    * Set Shared Key request.
    * @throws InterruptedException Thrown when a thread is waiting, sleeping,
    * or otherwise occupied, and the thread is interrupted, either before or
    * during the activity. Occasionally a method may wish to test whether the
    * current thread has been interrupted, and if so, to immediately throw
    * this exception. The following code can be used to achieve this effect:
    * @throws ExecutionException Thrown when attempting to retrieve the result
    * of a task that aborted by throwing an exception. This exception can be
    * inspected using the Throwable.getCause() method.
    * @throws ServiceException Thrown if the server returned an error for the
    * request.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is in
    * progress, or has failed. Note that this status is distinct from the HTTP
    * status code returned for the Get Operation Status operation itself. If
    * the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request. If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public GatewayGetOperationStatusResponse setSharedKey(String networkName, String localNetworkName, GatewaySetSharedKeyParameters parameters) throws InterruptedException, ExecutionException, ServiceException {
        NetworkManagementClient client2 = this.getClient();
        boolean shouldTrace = CloudTracing.getIsEnabled();
        String invocationId = null;
        if (shouldTrace) {
            invocationId = Long.toString(CloudTracing.getNextInvocationId());
            HashMap<String, Object> tracingParameters = new HashMap<String, Object>();
            tracingParameters.put("networkName", networkName);
            tracingParameters.put("localNetworkName", localNetworkName);
            tracingParameters.put("parameters", parameters);
            CloudTracing.enter(invocationId, this, "setSharedKeyAsync", tracingParameters);
        }
        if (shouldTrace) {
            client2 = this.getClient().withRequestFilterLast(new ClientRequestTrackingHandler(invocationId)).withResponseFilterLast(new ClientRequestTrackingHandler(invocationId));
        }
        
        GatewayOperationResponse response = client2.getGatewaysOperations().beginSetSharedKeyAsync(networkName, localNetworkName, parameters).get();
        GatewayGetOperationStatusResponse result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
        int delayInSeconds = 30;
        while ((result.getStatus() != GatewayOperationStatus.InProgress) == false) {
            Thread.sleep(delayInSeconds * 1000);
            result = client2.getGatewaysOperations().getOperationStatusAsync(response.getOperationId()).get();
            delayInSeconds = 30;
        }
        
        if (shouldTrace) {
            CloudTracing.exit(invocationId, result);
        }
        
        if (result.getStatus() != GatewayOperationStatus.Successful) {
            if (result.getError() != null) {
                ServiceException ex = new ServiceException(result.getError().getCode() + " : " + result.getError().getMessage());
                ex.setErrorCode(result.getError().getCode());
                ex.setErrorMessage(result.getError().getMessage());
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            } else {
                ServiceException ex = new ServiceException("");
                if (shouldTrace) {
                    CloudTracing.error(invocationId, ex);
                }
                throw ex;
            }
        }
        
        return result;
    }
}
